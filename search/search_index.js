var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":""},{"location":"index.html#ros-2-cookbook","title":"ROS 2 Cookbook","text":"<p>A collection of snippets ranging multiple topics in ROS 2.</p>"},{"location":"literate-nav.html","title":"Literate nav","text":"<ul> <li>Client Libraries<ul> <li>C++<ul> <li>Initialization</li> <li>Logging</li> <li>Nodes</li> <li>Parameters</li> <li>Pcl</li> <li>Tf2</li> <li>Time</li> <li>Workarounds</li> </ul> </li> <li>Python<ul> <li>Nodes</li> <li>Parameters</li> <li>Tf2</li> <li>Time</li> </ul> </li> </ul> </li> <li>Other<ul> <li>Bag</li> <li>Cmake</li> <li>Colcon</li> <li>Command_line</li> <li>Launch</li> <li>Networking</li> <li>Packages</li> <li>Qos</li> <li>Rosdep</li> <li>Rosdoc2</li> </ul> </li> </ul>"},{"location":"client_libraries/index.html","title":"Client Libraries","text":""},{"location":"client_libraries/index.html#client-libraries","title":"Client libraries","text":""},{"location":"client_libraries/index.html#c-rclcpp","title":"C++ (rclcpp)","text":""},{"location":"client_libraries/index.html#python-rclpy","title":"Python (rclpy)","text":""},{"location":"client_libraries/rclcpp/index.html","title":"C++","text":""},{"location":"client_libraries/rclcpp/index.html#c-rclcpp","title":"C++ (rclcpp)","text":""},{"location":"client_libraries/rclcpp/index.html#nodes","title":"Nodes","text":""},{"location":"client_libraries/rclcpp/index.html#parameters","title":"Parameters","text":""},{"location":"client_libraries/rclcpp/index.html#logging","title":"Logging","text":""},{"location":"client_libraries/rclcpp/index.html#time","title":"Time","text":""},{"location":"client_libraries/rclcpp/index.html#tf2","title":"TF2","text":""},{"location":"client_libraries/rclcpp/index.html#point-clouds","title":"Point Clouds","text":""},{"location":"client_libraries/rclcpp/index.html#workarounds","title":"Workarounds","text":""},{"location":"client_libraries/rclcpp/index.html#initialization","title":"Initialization","text":""},{"location":"client_libraries/rclcpp/initialization.html","title":"rclcpp: Initialization","text":""},{"location":"client_libraries/rclcpp/initialization.html#shared_from_this-cannot-be-used-in-constructor","title":"shared_from_this Cannot Be Used in Constructor","text":"<p>Sometime, you need to initialize some components outside of the constructor of your node. For example, you may want to initialize an object by passing a shared pointer to the node to it. This is not possible in the constructor, because the node is not fully initialized yet.</p> <p>The following pattern can be used to initialize components outside of the constructor of your node. This pattern was found through this comment.</p> <pre><code>// Class declaration\n\nclass InitializedComponent\n{\npublic:\n  COMPOSITION_PUBLIC\n  explicit InitializedComponent(const rclcpp::NodeOptions &amp; options);\n\n  COMPOSITION_PUBLIC\n  rclcpp::node_interfaces::NodeBaseInterface::SharedPtr\n  get_node_base_interface() const;\n\nprivate:\n  rclcpp::Node::SharedPtr node_;\n};\n\n// Class implementation\n\nInitializedComponent::InitializedComponent(const rclcpp::NodeOptions &amp; options)\n: node_(std::make_shared&lt;rclcpp::Node&gt;(\"node\", options))\n{\n  /* Do some initialization here */\n}\n\nrclcpp::node_interfaces::NodeBaseInterface::SharedPtr\nInitializedComponent::get_node_base_interface() const\n{\n  return this-&gt;node_-&gt;get_node_base_interface();\n}\n</code></pre>"},{"location":"client_libraries/rclcpp/initialization.html#overriding-default-parameters","title":"Overriding Default Parameters","text":"<p>This is a pattern I find especially helpful when writing tests, where I want to create several tests with different parameters but would rather not maintain separate YAML or launch files with parameters: <pre><code>rclcpp::NodeOptions options;\noptions.parameter_overrides(\n  {\n    {\"my_namespace.my_parameter\", 5.2},\n    {\"another_parameter\", \"new value\"},\n  }\n);\nauto node = std::make_shared&lt;rclcpp::Node&gt;(\"node_name\", options);\n</code></pre></p>"},{"location":"client_libraries/rclcpp/logging.html","title":"rclcpp: Logging","text":""},{"location":"client_libraries/rclcpp/logging.html#changing-the-logging-level","title":"Changing the logging level","text":"<pre><code>#include &lt;rclcpp/logger.hpp&gt;\n\nrclcpp::get_logger(\"nav2_costmap_2d\").set_level(rclcpp::Logger::Level::Debug);\n</code></pre>"},{"location":"client_libraries/rclcpp/nodes.html","title":"rclcpp: Nodes and Components","text":""},{"location":"client_libraries/rclcpp/nodes.html#creating-a-component","title":"Creating a Component","text":"<p>ROS 2 introduces components, which are nodes that can be run together in a single process. The benefits of using node compositions has been documented in a recent paper, Impact of ROS 2 Node Composition in Robotic Systems. Given the ease of use and the provided tooling, it really makes sense to make just about every node a component, and then let the rclcpp_components tooling create a node executable for you:</p> <pre><code>#include &lt;rclcpp/rclcpp.hpp&gt;\n\nnamespace my_pkg\n{\n\nclass MyComponent : public rclcpp::Node\n{\npublic:\n  MyComponent(const rclcpp::NodeOptions&amp; options)\n  : rclcpp::Node(\"node_name\", options)\n  {\n    // Do all your setup here - subscribers/publishers/timers\n    // After you return, an executor will be started\n\n    // Note: you cannot use shared_from_this()\n    //       here because the node is not fully\n    //       initialized.\n  }\n};\n\n}  // namespace my_pkg\n\n#include \"rclcpp_components/register_node_macro.hpp\"\nRCLCPP_COMPONENTS_REGISTER_NODE(my_pkg::MyComponent)\n</code></pre> <p>The in the CMakeLists.txt:</p> <pre><code>add_library(my_component SHARED\n  src/my_component.cpp\n)\nament_target_dependencies(my_component\n  rclcpp\n  rclcpp_components\n)\n\n# Also add a node executable which simply loads the component\nrclcpp_components_register_node(my_component\n  PLUGIN \"my_pkg::MyComponent\"\n  EXECUTABLE my_node\n)\n</code></pre>"},{"location":"client_libraries/rclcpp/nodes.html#executors","title":"Executors","text":"<p>To run an executor in a thread:</p> <pre><code>#include &lt;thread&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rclcpp/executors/single_threaded_executor.hpp&gt;\n\nrclcpp::executors::SingleThreadedExecutor executor;\n\n// Node is rclcpp::Node::SharedPtr instance\nexecutor.add_node(node);\nstd::thread executor_thread(\n  std::bind(&amp;rclcpp::executors::SingleThreadedExecutor::spin,\n            &amp;executor));\n</code></pre>"},{"location":"client_libraries/rclcpp/parameters.html","title":"rclcpp: Parameters","text":"<p>Parameters need to be declared. At the same time, you can get the value if you are not planning to update the value again later:</p> <pre><code>// node is an instance of rclcpp::Node\n// 42 is a great default for a parameter\nint param = node.declare_parameter&lt;int&gt;(\"my_param_name\", 42);\n</code></pre> <p>To get the value:</p> <pre><code>int param;\nnode.get_parameter(\"my_param_name\", param);\n</code></pre>"},{"location":"client_libraries/rclcpp/parameters.html#dynamic-parameters","title":"Dynamic Parameters","text":"<p>In ROS 2, all parameters can be dynamically updated through a ROS 2 service (there is no need to define duplicate stuff as with dynamic reconfigure).</p> <p>The example below works in Eloquent or later (earlier ROS 2 releases supported only a single callback and had a slightly different API). See the documentation for rclcpp::ParameterType for valid types.</p> <pre><code>#include &lt;vector&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n\nclass MyNode : public rclcpp::Node\n{\npublic:\n  MyNode()\n  {\n    // Declare parameters first\n\n    // Then create callback\n    param_cb_ = this-&gt;add_on_set_parameters_callback(\n      std::bind(&amp;MyNode::updateCallback, this, std::placeholders::_1));\n  }\n\nprivate:\n  // This will get called whenever a parameter gets updated\n  rcl_interfaces::msg::SetParametersResult updateCallback(\n    const std::vector&lt;rclcpp::Parameter&gt; &amp; parameters)\n  {\n    rcl_interfaces::msg::SetParametersResult result;\n    result.successful = true;\n\n    for (const rclcpp::Parameter &amp; param : parameters)\n    {\n      if (param.get_name() == \"my_param_name\")\n      {\n        if (param.get_type() != rclcpp::ParameterType::PARAMETER_STRING)\n        {\n          result.successful = false;\n          result.reason = \"my_param_name must be a string\";\n          break;\n        }\n\n        // Optionally do something with parameter\n      }\n    }\n\n    return result;\n  }\n\n  // Need to hold a pointer to the callback\n  rclcpp::node_interfaces::OnSetParametersCallbackHandle::SharedPtr param_cb_;\n};\n</code></pre>"},{"location":"client_libraries/rclcpp/parameters.html#porting-xml-arrays-to-ros-2","title":"Porting XML Arrays to ROS 2","text":"<p>Complex parameter blocks could be parsed as XML in ROS 1. For instance, the robot_calibration package used a block like:</p> <pre><code>models:\n - name: arm\n   type: chain\n   frame: wrist_roll_link\n - name: camera\n   type: camera3d\n   frame: head_camera_rgb_optical_frame\n</code></pre> <p>In ROS 2, the common pattern is to make the array a list of just names, then have each name be a block of parameters:</p> <pre><code>models:\n- arm\n- camera\narm:\n  type: chain3d\n  frame: wrist_roll_link\ncamera:\n  type: camera3d\n  frame: head_camera_rgb_optical_frame\n</code></pre> <p>To parse such a block:</p> <pre><code>std::vector&lt;ModelParams&gt; models;\nauto model_names = node-&gt;declare_parameter&lt;std::vector&lt;std::string&gt;&gt;(\"models\", std::vector&lt;std::string&gt;());\nfor (auto name : model_names)\n{\n  RCLCPP_INFO(logger, \"Adding model: %s\", name.c_str());\n  ModelParams params;\n  params.name = name;\n  params.type = node-&gt;declare_parameter&lt;std::string&gt;(name + \".type\", std::string());\n  params.frame = node-&gt;declare_parameter&lt;std::string&gt;(name + \".frame\", std::string());\n  params.param_name = node-&gt;declare_parameter&lt;std::string&gt;(name + \".param_name\", std::string());\n  models.push_back(params);\n}\n</code></pre>"},{"location":"client_libraries/rclcpp/pcl.html","title":"rclcpp: Point Clouds","text":"<p>The sensor_msgs/PointCloud2 is a very common type of ROS message for processing perception data in ROS. It is also one of the most complex messages to actually interpret.</p> <p>The complexity of the message derives from the fact that it holds arbitrary fields in a single giant data store. This allows the PointCloud2 message to work with any type of cloud (for instance, XYZ points only, XYZRGB, or even XYZI), but adds a bit of complexity in accessing the data in the cloud.</p> <p>In ROS 1, there was a simpler PointCloud message, but this has been deprecated and will be removed in ROS 2 Galactic.</p>"},{"location":"client_libraries/rclcpp/pcl.html#using-the-pointcloud2iterator","title":"Using the PointCloud2Iterator","text":"<p>The sensor_msgs package provides a C++ PointCloud2Iterator which can be used to create, modify and access PointCloud2 messages.</p> <p>To create a new message:</p> <pre><code>#include \"sensor_msgs/msg/point_cloud2.hpp\"\n#include \"sensor_msgs/point_cloud2_iterator.hpp\"\n\nsensor_msgs::msg::PointCloud2 msg;\n\n// Fill in the size of the cloud\nmsg.height = 480;\nmsg.width = 640;\n\n// Create the modifier to setup the fields and memory\nsensor_msgs::PointCloud2Modifier mod(msg);\n\n// Set the fields that our cloud will have\nmod.setPointCloud2FieldsByString(2, \"xyz\", \"rgb\");\n\n// Set up memory for our points\nmod.resize(msg.height * msg.width);\n\n// Now create iterators for fields\nsensor_msgs::PointCloud2Iterator&lt;float&gt; iter_x(cloud_msg, \"x\");\nsensor_msgs::PointCloud2Iterator&lt;float&gt; iter_y(cloud_msg, \"y\");\nsensor_msgs::PointCloud2Iterator&lt;float&gt; iter_z(cloud_msg, \"z\");\nsensor_msgs::PointCloud2Iterator&lt;uint8_t&gt; iter_r(cloud_msg, \"r\");\nsensor_msgs::PointCloud2Iterator&lt;uint8_t&gt; iter_g(cloud_msg, \"g\");\nsensor_msgs::PointCloud2Iterator&lt;uint8_t&gt; iter_b(cloud_msg, \"b\");\n\nfor (; iter_x != iter_x.end(); ++iter_x, ++iter_y, ++iter_z, ++iter_r, ++iter_g, ++iter_b)\n{\n  *iter_x = 0.0;\n  *iter_y = 0.0;\n  *iter_z = 0.0;\n  *iter_r = 0;\n  *iter_g = 255;\n  *iter_b = 0;\n}\n</code></pre>"},{"location":"client_libraries/rclcpp/pcl.html#using-pcl","title":"Using PCL","text":"<p>For a number of operations, you might want to convert to a pcl::PointCloud in order to use the extensive API of the Point Cloud Library.</p> <p>In ROS 1, the pcl_ros package allowed you to write a subscriber whose callback took a pcl::PointCloud directly, however this package has not yet been ported to ROS 2. Regardless, it is pretty straight forward to do the conversion yourself with the pcl_conversions package:</p> <pre><code>#include \"pcl_conversions/pcl_conversions.h\"\n\nvoid cloud_callback(const sensor_msgs::msg::PointCloud2::SharedPtr msg)\n{\n  // PCL still uses boost::shared_ptr internally\n  pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud =\n    boost::make_shared&lt;pcl::PointCloud&lt;pcl::PointXYZRGB&gt;&gt;();\n\n  // This will convert the message into a pcl::PointCloud\n  pcl::fromROSMsg(*msg, *cloud);\n}\n</code></pre> <p>You can also go in the opposite direction:</p> <pre><code>#include \"pcl_conversions/pcl_conversions.h\"\n\npcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud;\nsensor_msgs::msg::PointCloud2 msg;\n\npcl::toROSMsg(*cloud, msg);\ncloud_publisher-&gt;publish(msg);\n</code></pre>"},{"location":"client_libraries/rclcpp/tf2.html","title":"rclcpp: TF2","text":"<p>The TF2 library provides easy access to transformations. All of the examples below require a dependency on the tf2_ros package.</p>"},{"location":"client_libraries/rclcpp/tf2.html#broadcasting-transforms","title":"Broadcasting Transforms","text":"<pre><code>#include &lt;tf2_ros/transform_broadcaster.h&gt;\nstd::unique_ptr&lt;tf2_ros::TransformBroadcaster&gt; broadcaster;\n\nbroadcaster = std::make_unique&lt;tf2_ros::TransformBroadcaster&gt;(nodePtr);\n\ngeometry_msgs::msg::TransformStamped transform;\ntransform.header.stamp = node-&gt;now();\ntransform.header.frame_id = \"odom\";\ntransform.child_frame_id = \"base_link\";\n\n// Fill in transform.transform.translation\n// Fill in transform.transform.rotation\n\nbroadcaster-&gt;sendTransform(transform);\n</code></pre>"},{"location":"client_libraries/rclcpp/tf2.html#listening-for-transforms","title":"Listening for Transforms","text":"<pre><code>#include \"tf2_ros/transform_listener.h\"\n\nrclcpp::Node node(\"name_of_node\");\n\nauto tf_buffer = std::make_shared&lt;tf2_ros::Buffer&gt;(node.get_clock());\nauto tf_listener = std::make_shared&lt;tf2_ros::TransformListener&gt;(*tf_buffer);\n</code></pre>"},{"location":"client_libraries/rclcpp/tf2.html#applying-transforms","title":"Applying Transforms","text":"<p>TF2 can be extended by packages that provide implementations of transform. The tf2_geometry_msgs package provides these for _geometry_msgs. The example below uses geometry_msgs::msg::PointStamped - but this should work for any data type in geometry_msgs:</p> <pre><code>#include &lt;tf2_geometry_msgs/tf2_geometry_msgs.h&gt;\n\ngeometry_msg::msgs::PointStamped in, out;\nin.header.frame_id = \"source_frame\";\n\ntry\n{\n  tf_buffer-&gt;transform(in, out, \"target_frame\");\n}\ncatch (const tf2::TransformException&amp; ex)\n{\n  RCLCPP_ERROR(rclcpp::get_logger(\"logger_name\"), \"Could not transform point.\");\n}\n</code></pre> <p>The transform function can also take a timeout. It will then wait for the transform to be available up to that amount of time:</p> <pre><code>tf_buffer-&gt;transform(in, out, \"target_frame\", tf2::durationFromSec(1.0));\n</code></pre>"},{"location":"client_libraries/rclcpp/tf2.html#get-latest-transform","title":"Get Latest Transform","text":"<p>A common work flow is to get the \"latest\" transform. In ROS 2, this can be accomplished using tf2::TimePointZero, but requires using lookupTransform and then calling doTransform (which is basically what transform does internally):</p> <pre><code>geometry_msgs::msg::PointStamped in, out;\n\ngeometry_msgs::msg::TransformStamped transform =\n   tf_buffer-&gt;lookupTransform(\"target_frame\",\n                              in.header.frame_id,\n                              tf2::TimePointZero);\n\ntf2::doTransform(in, out, transform);\n</code></pre>"},{"location":"client_libraries/rclcpp/tf2.html#constructing-transform-from-euler-angles","title":"Constructing Transform from Euler Angles","text":"<p>There are numerous ways to do this (using Eigen, KDL, etc) - but it is also possible with only tf2 APIs:</p> <pre><code>#include &lt;tf2_geometry_msgs/tf2_geometry_msgs.hpp&gt;\n\ntf2::Quaternion quat;\n// While the documentation for tf2 orders the names of these as yaw, pitch, roll,\n// it specifies that yaw = rotation about Y, which is not what most of us expect\nquat.setEuler(pitch, roll, yaw);\n\ngeometry_msgs::msg::TransformStamped transform;\ntransform.transform.rotation = tf2::toMsg(quat);\n// Probably also fill in transform.header and transform.transform.translation\n\n// Can now use the transform with tf2::doTransform()\n</code></pre>"},{"location":"client_libraries/rclcpp/tf2.html#getting-yaw-angle-from-quaternion","title":"Getting Yaw Angle from Quaternion","text":"<pre><code>#include &lt;tf2_geometry_msgs/tf2_geometry_msgs.hpp&gt;\n#include &lt;tf2/utils.hpp&gt;\n\ngeometry_msgs::msg::Pose pose;\ndouble yaw = tf2::getYaw(pose.orientation);\n</code></pre> <p>[!NOTE] <code>tf2::getYaw</code> requires some pieces from <code>tf2_geometery_msgs/tf2_geometry_msgs.hpp</code> but cannot depend on them because it would create a circular dependency. This means you absolutely need to include tf2_geometry_msgs BEFORE tf2/utils or you will get an undefined reference to <code>tf2::fromMsg</code></p>"},{"location":"client_libraries/rclcpp/tf2.html#transform-from-eigenisometry3d","title":"Transform from Eigen::Isometry3d","text":"<pre><code>#include &lt;tf2_eigen/tf2_eigen.hpp&gt;\n\nEigen::Isometry3d map_to_odom;\ngeometry_msgs::msg::TransformStamped transform = tf2::eigenToTransform(map_to_odom);\n// Fill in header, child_frame_id\n</code></pre>"},{"location":"client_libraries/rclcpp/time.html","title":"rclcpp: Time","text":"<p>The rclcpp::Time and rclcpp::Duration are a significant departure from their ROS 1 equivalents, but are more closely related to std::chrono. For an in-depth discussion comparing with std::chrono, see this discussion on ROS Discourse.</p> <p>When porting certain ROS 1 libraries, there may be significant usage of timestamps as floating-point seconds. To get floating point seconds from an _rclcpp::Time_:</p> <pre><code>// node is instance of rclcpp::Node\nrclcpp::Time t = node.now();\ndouble seconds = t.seconds();\n</code></pre> <p>There is no constructor for Time from seconds represented by a floating point, so you first need to convert to nanoseconds:</p> <pre><code>rclcpp::Time t(static_cast&lt;uin64_t&gt;(seconds * 1e9));\n</code></pre> <p>rclcpp::Duration does have functions to go both directions:</p> <pre><code>rclcpp::Duration d = rclcpp::Duration::from_seconds(1.0);\ndouble seconds = d.seconds();\n</code></pre> <p>Unlike ROS 1, sleeping does NOT occur from a Duration instance:</p> <pre><code>rclcpp::sleep_for(std::chrono::milliseconds(50));\n</code></pre>"},{"location":"client_libraries/rclcpp/time.html#api-documentation-links","title":"API Documentation Links","text":"<ul> <li>rclcpp::Time</li> <li>rclcpp::Duration</li> </ul>"},{"location":"client_libraries/rclcpp/workarounds.html","title":"rclcpp: Workarounds","text":""},{"location":"client_libraries/rclcpp/workarounds.html#lazy-publishers","title":"Lazy Publishers","text":"<p>Prior to the Iron release, ROS 2 did not support subscriber connect callbacks. This code creates a function which is called periodically to check if we need to start or stop subscribers:</p> <pre><code>#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;std_msgs/msg/float64.hpp&gt;\n\nclass LazyPublisherEx : rclcpp::Node\n{\npublic:\n  LazyPublisherEx(const rclcpp::NodeOptions &amp; options) :\n    Node(\"lazy_ex\", options)\n  {\n    // Setup timer\n    timer = this-&gt;create_wall_timer(\n      std::chrono::seconds(1),\n      std::bind(&amp;LazyPublisher::periodic, this));\n  }\n\nprivate:\n  void periodic()\n  {\n    if (pub_.get_subscription_count() &gt; 0)\n    {\n        // We have a subscriber, do any setup required\n    }\n    else\n    {\n        // Subscriber has disconnected, do any shutdown\n    }\n  }\n\n  rclcpp::Publisher&lt;std_msgs::msg::Float64&gt;::SharedPtr pub_;\n  rclcpp::TimerBase::SharedPtr timer_;\n};\n</code></pre> <p>The same can be done when using image transport, you simply have to change from get_subscription_count to getNumSubscribers:</p> <pre><code>#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;image_transport/image_transport.h&gt;\n\nclass LazyPublisherEx : rclcpp::Node\n{\npublic:\n  LazyPublisherEx(const rclcpp::NodeOptions &amp; options) :\n    Node(\"lazy_ex\", options)\n  {\n    // Setup timer\n    timer = this-&gt;create_wall_timer(\n      std::chrono::seconds(1),\n      std::bind(&amp;LazyPublisher::periodic, this));\n  }\n\nprivate:\n  void periodic()\n  {\n    if (pub_.getNumSubscribers() &gt; 0)\n    {\n        // We have a subscriber, do any setup required\n    }\n    else\n    {\n        // Subscriber has disconnected, do any shutdown\n    }\n  }\n\n  image_transport::CameraPublisher pub_;\n  rclcpp::TimerBase::SharedPtr timer_;\n};\n</code></pre>"},{"location":"client_libraries/rclpy/index.html","title":"Python","text":""},{"location":"client_libraries/rclpy/index.html#python-rclpy","title":"Python (rclpy)","text":""},{"location":"client_libraries/rclpy/index.html#nodes","title":"Nodes","text":""},{"location":"client_libraries/rclpy/index.html#parameters","title":"Parameters","text":""},{"location":"client_libraries/rclpy/index.html#time","title":"Time","text":""},{"location":"client_libraries/rclpy/index.html#tf2","title":"TF2","text":""},{"location":"client_libraries/rclpy/nodes.html","title":"rclpy: Node Basics","text":"<p>Most nodes have publishers and subscribers, both of which are creating by calling functions of the Node instance:</p> <pre><code>import rclpy\nfrom rclpy.node import Node\n\nfrom std_msgs.msg import String\n\nclass MyNode(Node):\n\n    def __init__(self):\n        super().__init__('my_node_name')\n\n        self.publisher = self.create_publisher(String, 'output_topic', 10)\n        self.subscription = self.create_subscription(\n            String,\n            'input_topic',\n            self.callback,\n            10)\n\n    def callback(self, msg):\n        self.get_logger().info(\"Recieved: %s\" % msg.data)\n        self.publisher.publish(msg)\n\nif __name__ == \"__main__\":\n    rclpy.init()\n    my_node = MyNode()\n    rclpy.spin(my_node)\n    my_node.destroy_node()  # cleans up pub-subs, etc\n    rclpy.shutdown()\n</code></pre>"},{"location":"client_libraries/rclpy/nodes.html#shutdown-hooks","title":"Shutdown Hooks","text":"<p>ROS 1 had rospy.on_shutdown() - but there is not an equivalent in ROS 2. It really is not needed though, since we manually shut things down rather than was the case in rospy which used many global variables:</p> <pre><code>try:\n    rclpy.spin(my_node)\nexcept KeyboardInterrupt:\n    pass\nfinally:\n    my_node.on_shutdown()  # do any custom cleanup\n    my_node.destroy_node()\n    rclpy.shutdown()\n</code></pre>"},{"location":"client_libraries/rclpy/parameters.html","title":"rclpy: Parameters","text":""},{"location":"client_libraries/rclpy/parameters.html#declaring-and-accessing-parameters","title":"Declaring and Accessing Parameters","text":"<pre><code># node is rclpy.node.Node instance\n# 42 is a great default for a parameter\nnode.declare_parameter('my_param_name', 42)\n\n# To get the value:\nparam = node.get_parameter('my_param_name').value\n</code></pre>"},{"location":"client_libraries/rclpy/parameters.html#declaring-multiple-parameters-at-once","title":"Declaring Multiple Parameters at Once","text":"<p>There seems to be a fairly undocumentated part of the rclpy API:</p> <pre><code>node.declare_parameters(\n    namespace='',\n    parameters=[\n        ('my_param_name', 'default value'),\n        ('my_other_param', 42)\n    ]\n)\n</code></pre>"},{"location":"client_libraries/rclpy/parameters.html#dynamic-parameters","title":"Dynamic Parameters","text":"<p>In ROS 2, all parameters can be dynamically updated through a ROS 2 service (there is no need to define duplicate stuff as with dynamic reconfigure).</p> <pre><code>from rcl_interfaces.msg import SetParametersResult\n\nimport rclpy\nfrom rclpy.node import Node\n\nclass MyNode(Node):\n\n    def __init__(self):\n        super().__init__('my_node_name')\n\n        # Declare a parameter\n        self.declare_parameter('my_param_name', 42)\n\n        # Then create callback\n        self.add_on_set_parameters_callback(self.callback)\n\n    def callback(self, parameters):\n        result = SetParametersResult(successful=True)\n\n        for p in parameters:\n            if p.name == 'my_param_name':\n                if p.type_ != p.Type.INTEGER:\n                    result.successful = False\n                    result.reason = 'my_param_name must be an Integer'\n                    return result\n                if p.value &lt; 20:\n                    result.successful = False\n                    result.reason = 'my_param_name must be &gt;= 20;\n                    return result\n\n        # Return success, so updates are seen via get_parameter()\n        return result\n</code></pre> <p>For an example of calling the set_parameters service, see ROS Answers</p>"},{"location":"client_libraries/rclpy/parameters.html#getting-parameters-from-other-nodes","title":"Getting parameters from other nodes","text":"<p>In ros2, this is done through a service call. For example, to get the <code>robot_description</code> parameter published by <code>robot_state_publisher</code>:</p> <pre><code>from rcl_interfaces.srv import GetParameters\n\nimport rclpy\nfrom rclpy.node import Node\n\nclass GetParam(Node):\n    def __init__(self):\n        super().__init__('joint_command_publisher')\n        self.client = self.create_client(GetParameters, '/robot_state_publisher/get_parameters')\n        robot_description = self.get_robot_description()\n\n    def get_robot_description(self):\n        request = GetParameters.Request()\n        request.names = [\"robot_description\"]\n        future = self.client.call_async(request)\n        rclpy.spin_until_future_complete(self, future)\n        if future.result() is not None:\n            self.get_logger().info(future.result().values[0].string_value )\n            return future.result().values[0].string_value  # Assuming the parameter is a string, adjust as necessary\n        else:\n            self.get_logger().error('Failed to call service')\n            return None\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = GetParam()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n\n    node.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"client_libraries/rclpy/tf2.html","title":"rclpy: TF2","text":"<p>The TF2 library provides easy access to transformations. All of the examples below require a dependency on the tf2_ros package.</p>"},{"location":"client_libraries/rclpy/tf2.html#listening-for-transforms","title":"Listening for Transforms","text":"<pre><code>import rclpy\nfrom rclpy.node import Node\nfrom tf2_ros.buffer import Buffer\nfrom tf2_ros.transform_listener import TransformListener\n\nclass MyNode(Node):\n    def __init__(self):\n        super().__init__('my_node')\n\n        self.buffer = Buffer()\n        self.listener = TransformListener(self.buffer, self)\n</code></pre>"},{"location":"client_libraries/rclpy/tf2.html#applying-transforms","title":"Applying Transforms","text":"<p>TF2 can be extended by packages that provide implementations of transform. The tf2_geometry_msgs package provides these for _geometry_msgs. The example below uses geometry_msgs.msg.PointStamped - but this should work for any data type in geometry_msgs:</p> <pre><code>from geometry_msgs.msg import PointStamped\nfrom tf2_ros.buffer import Buffer\nfrom tf2_ros.transform_listener import TransformListener\nimport tf2_geometry_msgs\n\n# Setup buffer/listener as above\n\np1 = PointStamped()\np1.header.frame_id = 'source_frame'\n# fill in p1\n\np2 = buffer.transform(p1, 'target_frame')\n</code></pre>"},{"location":"client_libraries/rclpy/tf2.html#using-the-latest-transform","title":"Using the Latest Transform","text":"<pre><code>from rclpy.time import Time\n\n# Setting the stamp to a blank Time() instance will use the latest available data\np1 = PointStamped()\np1.header.frame_id = 'source_frame'\np1.header.stamp = Time().to_msg()\n\np2 = buffer.transform(p1, 'target_frame')\n</code></pre>"},{"location":"client_libraries/rclpy/tf2.html#transformations","title":"Transformations","text":"<p>In ROS 1, tf included the transformations module. tf2 has no similar module. It is recommended to use transforms3d Python package, which is available through apt on Ubuntu 22.04:</p> <pre><code>sudo apt-get install python3-transforms3d\n</code></pre> <p>Or via pip on other operating systems:</p> <pre><code>sudo pip3 install transforms3d\n</code></pre> <p>For instance, to rotate a point:</p> <pre><code>import numpy as np\nfrom transforms3d.quaternion import quat2mat\n\n# Create rotation matrix from quaternion\nR = quat2mat([w, x, y, z])\n# Create a vector to rotate\nV = np.array([x, y, z]).reshape((3, 1))\n# Rotate the vector\nM = np.dot(R, V)\n\np = PointStamped()\np.point.x = M[0, 0]\np.point.y = M[1, 0]\np.point.z = M[2, 0]\n</code></pre> <p>Additionally, in ROS 2 Humble there is the tf_transformations package which should make it as easy as changing your imports from tf.transformations to tf_transformations.</p>"},{"location":"client_libraries/rclpy/time.html","title":"rclpy: Time","text":"<p>There are four separate ways that you may see time represented in ROS 2:  * Plain ol' <code>int</code>: representing a number of nanoseconds.  * <code>float</code>: representing the fractional number of seconds  * <code>rclpy.time.Time</code> - the preferred Pythonic interface  * <code>builtin_interfaces/msg/Time.msg</code>: the message representation.</p> <p>Here's how you can convert them. | Converting this \u2192to this \u2193 | int                            | float                                                                                              | rclpy                 | msg                       | |--------------------------------|--------------------------------|----------------------------------------------------------------------------------------------------|-----------------------|---------------------------| | int                            | -                              | <code>int(t * 1e9)</code>                                                                                     | <code>t.nanoseconds</code>       | <code>t.sec * 1e9 + t.nanosec</code> | | float                          | <code>t / 1e9</code>                      | -                                                                                                  | <code>t.nanoseconds / 1e9</code> | <code>t.sec + t.nanosec / 1e9</code> | | rclpy                          | <code>Time(nanoseconds=t)</code>          | <code>nano, sec = math.modf(t)</code><code>Time(int(sec), int(nano * 1e9))</code>                                    | -                     | <code>Time.from_msg(t)</code>        | | msg                            | <code>Time(nanoseconds=t).to_msg()</code> | <code>nano, sec = math.modf(t)</code><code>builtin_interfaces.msg.Time(sec=int(sec), nanosec=int(nano * 1e9))</code> | <code>t.to_msg()</code>          | -                         |</p> <p>Important notes:  * You cannot do comparisons/math between mixed types or messages  * It is only mildly infuriating that <code>rclpy.time.Time</code> has the full word <code>nanoseconds</code> accessor and the message has <code>nanosec</code>.</p>"},{"location":"client_libraries/rclpy/time.html#now","title":"Now","text":"<p>To get the equivalent of rospy.Time.now(), you now need a ROS 2 node:</p> <pre><code>import rclpy\nfrom rclpy.node import Node\n\nclass MyNode(Node):\n\n    def some_func(self):\n        t = self.get_clock().now()\n        msg.header.stamp = t.to_msg()\n</code></pre> <p>Converting from Duration to messages is common:</p> <pre><code>import rclpy\nfrom rclpy.duration import Duration\n\nmsg.duration = Duration(seconds=1).to_msg()\n</code></pre>"},{"location":"client_libraries/rclpy/time.html#timers","title":"Timers","text":"<p>Timers are created from the Node:</p> <pre><code>import rclpy\nfrom rclpy.node import Node\n\nclass MyNode(Node):\n\n    def __init__(self):\n        super().__init__(\"my_node\")\n\n        # Create a timer that fires every quarter second\n        timer_period = 0.25\n        self.timer = self.create_timer(timer_period, self.callback)\n\n    def callback(self):\n        self.get_logger().info(\"timer has fired\")\n</code></pre>"},{"location":"client_libraries/rclpy/time.html#rates","title":"Rates","text":"<p>Using Rate objects in ROS 2 is a bit more complex than in ROS 1. Due to implementation details, we need to spin() or the sleep() function will block. This is most easily accomplished using a thread:</p> <pre><code>import threading\n\n# Run spin in a thread, make thread daemon so we don't have to join it to exit\nthread = threading.Thread(target=rclpy.spin, args=(node, ), daemon=True)\nthread.start()\n\nrate = node.create_rate(10)\nwhile rclpy.ok():\n    print('This prints at 10hz')\n    rate.sleep()\n</code></pre>"},{"location":"other/pages/index.html","title":"Other","text":""},{"location":"other/pages/index.html#other","title":"Other","text":""},{"location":"other/pages/index.html#rosbag2","title":"rosbag2","text":""},{"location":"other/pages/index.html#cmake","title":"CMake","text":""},{"location":"other/pages/index.html#colcon","title":"colcon","text":""},{"location":"other/pages/index.html#command-line-tools","title":"Command Line Tools","text":""},{"location":"other/pages/index.html#ros2launch","title":"ros2launch","text":""},{"location":"other/pages/index.html#networking-dds-cyclonedds","title":"Networking (DDS &amp; CycloneDDS)","text":""},{"location":"other/pages/index.html#package-documentation","title":"Package Documentation","text":""},{"location":"other/pages/index.html#qos-quality-of-service","title":"QoS (Quality of Service)","text":""},{"location":"other/pages/index.html#documenting-with-rosdoc2","title":"Documenting with rosdoc2","text":""},{"location":"other/pages/index.html#rosdep","title":"rosdep","text":""},{"location":"other/pages/bag.html","title":"rosbag2","text":""},{"location":"other/pages/bag.html#common-command-line","title":"Common Command Line","text":"<ul> <li><code>ros2 bag record /topic1 /topic2</code></li> <li>When playing a bagfile back, you usually want clock topic:</li> <li><code>ros2 bag play &lt;bagfile&gt; --clock</code></li> <li>For nodes to use the clock topic, specify use_sim_time:</li> <li><code>ros2 run rviz2 rviz2 --ros-args -p use_sim_time:=true</code></li> </ul>"},{"location":"other/pages/bag.html#api-tutorials","title":"API Tutorials","text":"<p>The ROS documentation has tutorials for recording and playback, which are linked below. There is no official tutorial for reading from a bagfile in Python, the linked one comes from an MCAP tutorial:</p> <ul> <li>Record in C++</li> <li>Playback in C++</li> <li>Record in Python</li> <li>Playback in Python</li> </ul>"},{"location":"other/pages/bag.html#converting-bag-files-from-ros-1","title":"Converting Bag Files from ROS 1","text":"<p>The following works, assuming you are mainly using standard topics. For instance, I have converted a number of bagfiles intended for SLAM testing, which mainly consist of sensor_msgs::LaserScan, TF, and nav_msgs::Odometry data.</p> <p>The easiest route for converting bagfiles is to use <code>rosbags</code>:</p> <pre><code>sudo pip3 install rosbags\nrosbag-convert bagfile_name.bag\n</code></pre> <p>This will create a new folder with the name <code>bagfile_name</code> containing the SQLite file and the index file. At this point, you can inspect the bagfile:</p> <pre><code>ros2 bag info bagfile_name\n\nFiles:             bagfile_name.db3\nBag size:          65.7 MiB\nStorage id:        sqlite3\nROS Distro:        rosbags\nDuration:          122.298s\nStart:             Jun 15 2014 21:41:49.861 (1402882909.861)\nEnd:               Jun 15 2014 21:43:52.159 (1402883032.159)\nMessages:          35187\nTopic information: Topic: odom | Type: nav_msgs/msg/Odometry | Count: 12141 | Serialization Format: cdr\n                   Topic: tf | Type: tf2_msgs/msg/TFMessage | Count: 16939 | Serialization Format: cdr\n                   Topic: base_scan | Type: sensor_msgs/msg/LaserScan | Count: 4884 | Serialization Format: cdr\n                   Topic: odom_combined | Type: nav_msgs/msg/Odometry | Count: 1223 | Serialization Format: cdr\n</code></pre> <p>This bagfile is now useable in ROS 2. However, you can also go a bit further by compressing the bagfile, and migrating it to the new MCAP file format. First, create a YAML file to define the output format:</p> <pre><code># output_format.yaml\noutput_bags:\n- uri: bagfile_name_compressed\n  all: true\n  compression_mode: file\n  compression_format: zstd\n</code></pre> <p>Now, run the conversion:</p> <pre><code>ros2 bag convert -i bagfile_name -o output_format.yaml\n</code></pre> <p>Inspecting the new bag, we can see that compression is very nice - a 75% reduction in file size for my typical SLAM bag files:</p> <pre><code>ros2 bag info bagfile_name_compressed\n\nFiles:             bagfile_name_compressed.mcap.zstd\nBag size:          16.7 MiB\nStorage id:        mcap\nROS Distro:        rolling\nDuration:          122.298s\nStart:             Jun 15 2014 21:41:49.861 (1402882909.861)\nEnd:               Jun 15 2014 21:43:52.159 (1402883032.159)\nMessages:          35187\nTopic information: Topic: base_scan | Type: sensor_msgs/msg/LaserScan | Count: 4884 | Serialization Format: cdr\n                   Topic: odom | Type: nav_msgs/msg/Odometry | Count: 12141 | Serialization Format: cdr\n                   Topic: odom_combined | Type: nav_msgs/msg/Odometry | Count: 1223 | Serialization Format: cdr\n                   Topic: tf | Type: tf2_msgs/msg/TFMessage | Count: 16939 | Serialization Format: cdr\n</code></pre>"},{"location":"other/pages/bag.html#removing-tf-from-a-bagfile","title":"Removing TF from a Bagfile","text":"<p>I have often found that I needed to remove problematic TF data from a bagfile, usually filtering out the <code>odom-&gt;base_link</code> transform so that I can replace it with a more sophisticated filtered one. In this particular example we just toss the whole message out - but you could selectively remove the individual transform within the message and serialize the edited message back up.</p> <pre><code>import rosbag2_py\nfrom rclpy.serialization import deserialize_message\nfrom rosidl_runtime_py.utilities import get_message\n\nreader = rosbag2_py.SequentialReader()\nreader.open(\n    rosbag2_py.StorageOptions(uri='input_bag', storage_id='mcap'),\n    rosbag2_py.ConverterOptions(input_serialization_format='cdr',\n                                output_serialization_format='cdr')\n)\n\nwriter = rosbag2_py.SequentialWriter()\nwriter.open(\n    rosbag2_py.StorageOptions(uri='output_bag', storage_id='mcap'),\n    rosbag2_py.ConverterOptions('', '')\n)\n\n# First preprocess the topics\ntopic_types = reader.get_all_topics_and_types()\nfor topic_type in topic_types:\n    # Setup output bagfile - same topics as input\n    writer.create_topic(topic_type)\n    # Note the type if this is our TF data\n    if topic_type.name == '/tf':\n        tf_typename = topic_type.type\n\n# Now iterate through messages, copying over the ones we don't filter\nwhile reader.has_next():\n    topic, data, timestamp = reader.read_next()\n    filter_out = False\n    # Filter out odom tf messages\n    if topic == '/tf':\n        # Deserialize the message so we can look at it\n        msg_type = get_message(tf_typename)\n        msg = deserialize_message(data, msg_type)\n        # Iterate through the transforms in the message\n        for transform in msg.transforms:\n            if transform.header.frame_id == 'odom':\n                # Toss this message\n                filter_out = True\n                break\n    # Copy over message if it isn't odom\n    if not filter_out:\n        writer.write(topic, data, timestamp)\n</code></pre>"},{"location":"other/pages/cmake.html","title":"CMake","text":"<p>While you don't need to know everything about CMake to use ROS 2, knowing a bit will really be helpful. You might be interested in the CMake tutorial which explains the basics of CMake.</p>"},{"location":"other/pages/cmake.html#ament","title":"Ament","text":"<p>Ament is a set of CMake modules specifically designed for ROS 2 with the intent of making CMake easier to use. See the Ament CMake documentation.</p> <p>The basic structure of an ament package:</p> <pre><code>cmake_minimum_required(VERSION 3.8)\nproject(my_package_name)\n\n# Default to C++17\nif(NOT CMAKE_CXX_STANDARD)\n  set(CMAKE_CXX_STANDARD 17)\nendif()\n\nif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  add_compile_options(-Wall -Wextra -Wpedantic)\nendif()\n\n# Find packages\nfind_package(ament_cmake REQUIRED)\nfind_package(rclcpp REQUIRED)\n\n# Include our own headers\ninclude_directories(include)\n\n# Create a node\nadd_executable(my_node src/my_node.cpp)\nament_target_dependencies(my_node\n  rclcpp\n  # Other ament dependencies\n  # This sets up include and linker paths\n)\n\nadd_library(my_library src/my_library.cpp)\nament_target_dependencies(my_library\n  rclcpp\n)\n\n# Install our headers\ninstall(\n  DIRECTORY include/\n  DESTINATION include\n)\n\n# Install our node and library\ninstall(\n  TARGETS my_node my_library\n  ARCHIVE DESTINATION lib\n  LIBRARY DESTINATION lib\n  RUNTIME DESTINATION lib/${PACKAGE_NAME}\n)\n\n# Install some Python scripts\ninstall(\n  PROGRAMS\n    scripts/my_script.py\n  DESTINATION\n    lib/${PROJECT_NAME}\n)\n\n# Tell downstream packages where to find our headers\nament_export_include_directories(include)\n# Tell downstream packages our libraries to link against\nament_export_libraries(my_library)\n# Help downstream packages to find transitive dependencies\nament_export_dependencies(\n  rclcpp\n)\nament_package()\n</code></pre>"},{"location":"other/pages/cmake.html#linting-configuration","title":"Linting Configuration","text":"<p>I prefer a more ROS 1-style code style. To allow braces to be on their own lines:</p> <pre><code>if(BUILD_TESTING)\n  find_package(ament_cmake_cpplint)\n  ament_cpplint(FILTERS \"-whitespace/braces\" \"-whitespace/newline\")\nendif()\n</code></pre>"},{"location":"other/pages/cmake.html#installing-python-scripts","title":"Installing Python Scripts","text":"<pre><code>install(\n  PROGRAMS\n    scripts/script1.py\n    scripts/script2.py\n  DESTINATION lib/${PROJECT_NAME}\n)\n</code></pre>"},{"location":"other/pages/cmake.html#depending-on-messages-in-same-package","title":"Depending on Messages in Same Package","text":"<p>It is generally best practice to put messages in separate packages, but sometimes, especially for drivers, you want the messages in the same package.</p> <p>The following example worked in earlier versions of ROS 2 - but the syntax has changed See the Implementing custom interfaces tutorial for newer ROS 2 distributions.</p> <pre><code># Note: this WILL NOT work in ROS 2 Humble or later\nfind_package(rosidl_default_generators REQUIRED)\n\n# Generate some messages\nrosidl_generate_interfaces(${PROJECT_NAME}\n  \"msg/MyMessage.msg\"\n)\n\n# Add a node which uses the messages\nadd_executable(my_node my_node.cpp)\nrosidl_target_interfaces(my_node ${PROJECT_NAME} \"rosidl_typesupport_cpp\")\n</code></pre>"},{"location":"other/pages/cmake.html#removing-boost-from-pluginlib","title":"Removing Boost from Pluginlib","text":"<p>Pluginlib supports both boost::shared_ptrs and std::shared_ptrs by default, if you want to avoid depending on Boost in your shiny new ROS 2 library, you need to specifically tell pluginlib not to include the Boost versions:</p> <pre><code>target_compile_definitions(your_library PUBLIC \"PLUGINLIB__DISABLE_BOOST_FUNCTIONS\")\n</code></pre>"},{"location":"other/pages/cmake.html#using-eigen3","title":"Using Eigen3","text":"<p>Add eigen to your package.xml as a dependency, and then:</p> <pre><code>find_package(Eigen3 REQUIRED)\ninclude_directories(${EIGEN3_INCLUDE_DIRS})\n</code></pre>"},{"location":"other/pages/cmake.html#building-python-extensions-in-c","title":"Building Python Extensions in C++","text":"<p>The example below is based on the etherbotix package.</p> <pre><code>find_package(PythonLibs REQUIRED)\nfind_package(Boost REQUIRED python)\nfind_package(ament_cmake_python REQUIRED)\nfind_package(python_cmake_module REQUIRED)\n\nament_python_install_package(${PROJECT_NAME})\n\nadd_library(\n  my_python SHARED\n  ${SOURCE_FILES}\n)\nset_target_properties(\n  my_python PROPERTIES\n  LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}\n  PREFIX \"\"\n)\ntarget_link_libraries(my_python\n  ${Boost_LIBRARIES}\n  ${PYTHON_LIBRARIES}\n)\n\ninstall(\n  TARGETS my_python\n  DESTINATION \"${PYTHON_INSTALL_DIR}/${PROJECT_NAME}\"\n)\n</code></pre>"},{"location":"other/pages/colcon.html","title":"Command Line: Colcon","text":""},{"location":"other/pages/colcon.html#my-aliases","title":"My Aliases","text":"<p>I hate typing - so these are the aliases in my <code>~/.bashrc</code> for my most common workflow:</p> <pre><code>alias build2=\"colcon build --symlink-install\"\nalias test2=\"colcon test --event-handlers console_direct+\"\n</code></pre>"},{"location":"other/pages/colcon.html#build","title":"Build","text":"<p>colcon is used to build ROS 2 packages in a workspace.</p> <p>Build all packages:</p> <pre><code>colcon build\n</code></pre> <p>To avoid having to rebuild when tweaking Python scripts, config files, and launch files:</p> <pre><code>colcon build --symlink-install\n</code></pre> <p>To fix most build issues, especially if you have added or removed packages to your workspace or installed new RMW implementations, clean the CMake cache. See this ROS Answers post for more details.</p> <pre><code>colcon build --cmake-clean-cache\n</code></pre>"},{"location":"other/pages/colcon.html#cmake-arguments","title":"CMake Arguments","text":"<pre><code>colcon build --cmake-args -DCMAKE_BUILD_TYPE=RelWithDebInfo\n</code></pre>"},{"location":"other/pages/colcon.html#test","title":"Test","text":"<p>To test and get results to screen:</p> <pre><code>colcon test\ncolcon test-result --verbose\n</code></pre> <p>Build/test a single package:</p> <pre><code>colcon &lt;verb&gt; --packages-select &lt;package-name&gt;\n</code></pre>"},{"location":"other/pages/colcon.html#formatting","title":"Formatting","text":"<p>Get the output to the screen:</p> <pre><code>colcon &lt;verb&gt; --event-handlers console_direct+\n</code></pre>"},{"location":"other/pages/colcon.html#be-careful-with-workspaces","title":"Be Careful With Workspaces","text":"<p>You should probably build your workspace in a window where you have NOT sourced the setup.bash of that workspace. For more details on why, see this ticket.</p>"},{"location":"other/pages/colcon.html#verb-documentation","title":"Verb Documentation","text":"<ul> <li>build</li> <li>test</li> </ul>"},{"location":"other/pages/command_line.html","title":"Command Line Tools","text":"<ul> <li><code>ros2 run &lt;pkg&gt; &lt;node&gt;</code></li> <li><code>ros2 node list</code></li> <li><code>ros2 topic list</code></li> <li><code>ros2 topic info &lt;topic_name&gt; --verbose</code> gives details about QoS.</li> <li><code>ros2 param list</code></li> <li><code>ros2 doctor --report</code> gives tons of information.</li> </ul>"},{"location":"other/pages/launch.html","title":"roslaunch2","text":"<p>See also rosetta_launch for a number of examples.</p>"},{"location":"other/pages/launch.html#python-based-launch-files","title":"Python-Based Launch Files","text":"<p>Python-based launch files all pretty much follow the same structure.</p> <p>[!NOTE] Prior to Foxy, the parameters name, namespace, and executable were prefixed with node_</p> <pre><code>from launch import LaunchDescription\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    return LaunchDescription([\n        Node(\n            name='node_runtime_name',\n            package='ros2_package_name',\n            executable='name_of_executable',\n            parameters=[{'name_of_int_param': 1,\n                         'name_of_str_param': 'value'}],\n            remappings=[('from', 'to')],\n            output='screen',\n        ),\n        # More Nodes!\n    ])\n</code></pre>"},{"location":"other/pages/launch.html#making-a-launch-file-executable","title":"Making a Launch File Executable","text":"<p>Normally, launch files are run with:</p> <pre><code>ros2 launch pkg launch.py\n</code></pre> <p>But, sometimes you want an executable launch file (for instance to put in a systemd job). Assuming you follow the default pattern shown above, all you need to add:</p> <pre><code>#!/usr/bin/env python3\n\nimport sys\nfrom launch import LaunchService\n\n# define generate_launch_description() as above\n\nif __name__ == '__main__':\n    desc = generate_launch_description()\n    service = LaunchService(argv=sys.argv[1:])\n    service.include_launch_description(desc)\n    return service.run()\n</code></pre>"},{"location":"other/pages/launch.html#loading-parameters-from-a-file","title":"Loading Parameters From a File","text":"<p>Some nodes have many parameters, it's easier to put them in a YAML file:</p> <pre><code>node_name:\n  ros__parameters:\n      some_int_param: 1\n      some_str_param: \"the_value\"\n</code></pre> <p>To load this:</p> <pre><code>from ament_index_python.packages import get_package_share_directory\n\n# Assuming you have a file called package_name/config/params.yaml\nnode_params = os.path.join(\n    get_package_share_directory('package_name'),\n    'config',\n    'params.yaml'\n)\n\n# Add this to your LaunchDescription\nNode(\n    name='node_runtime_name',\n    package='ros2_package_name',\n    executable='name_of_executable',\n    parameters=[{'another_param': 42.0},\n                 node_params]\n)\n</code></pre>"},{"location":"other/pages/launch.html#including-python-launch-files","title":"Including Python Launch Files","text":"<pre><code>import os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\n\n# Assuming you have a file called package_name/launch/my_launch.launch.py\nmy_launch_file = os.path.join(\n    get_package_share_directory('package_name'),\n    'launch',\n    'my_launch.launch.py'\n)\n\n# Add this to your LaunchDescription\nIncludeLaunchDescription(\n    PythonLaunchDescriptionSource([my_launch_file])\n),\n</code></pre>"},{"location":"other/pages/launch.html#loading-a-urdf","title":"Loading a URDF","text":"<p>Most robots need to load their URDF into the robot_state_publisher, and maybe other nodes as well:</p> <pre><code>import os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch_ros.actions import Node\n\n# Load the URDF into a parameter\ndesc_dir = get_package_share_directory('robot_description_pkg')\nurdf_path = os.path.join(desc_dir, 'robots', 'my_urdf.urdf')\nurdf = open(urdf_path).read()\n\n# Add this to your LaunchDescription\nNode(\n    name='robot_state_publisher',\n    package='robot_state_publisher',\n    executable='robot_state_publisher',\n    parameters=[{'robot_description': urdf}],\n)\n</code></pre>"},{"location":"other/pages/launch.html#installing-launch-files","title":"Installing Launch Files","text":"<ul> <li>Launch System Tutorial</li> </ul>"},{"location":"other/pages/networking.html","title":"Networking","text":"<p>ROS 2 uses DDS for message transport.</p> <p>Set the environment variable RMW_IMPLEMENTATION to select a DDS implementation (RMW = robotic middleware). For instance:</p> <pre><code>export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp\n</code></pre> <p>To check which RMW implementation is being used:</p> <pre><code>ros2 doctor --report | grep middleware\n</code></pre>"},{"location":"other/pages/networking.html#dds-discovery","title":"DDS Discovery","text":"<p>There is no rosmaster like in ROS 1. Node discovery is peer-to-peer with nodes announcing their topics on startup and periodically after that. By default, any machines on the same network will see each other if they have the same ROS_DOMAIN_ID.</p> <p>ROS_DOMAIN_ID can be any number between 0 and 253, although it is recommended to use numbers less than 128.</p> <p>In addition to the ROS_DOMAIN_ID, CycloneDDS supports a domain tag, which allows nearly infinite partitioning of the network (see below).</p> <p>If you want to limit communication to the localhost set ROS_LOCALHOST_ONLY, which is available since Eloquent.</p>"},{"location":"other/pages/networking.html#cyclonedds","title":"CycloneDDS","text":"<p>Cyclone can be configured with XML. This can be stored in a file or passed directly in the environment variable CYCLONEDDS_URI. A full list of supported options can be found in the eclipse-cyclonedds repo. See also the Guide to Configuration.</p>"},{"location":"other/pages/networking.html#cyclonedds-large-topics-fail-with-best-effort-subscribers","title":"CycloneDDS: Large Topics Fail with Best Effort Subscribers","text":"<p>Starting with ROS 2 Jazzy, I noticed an issue where best effort subscribers no longer transmitted data for large topics (point clouds and images). This was fixed by applying the buffer size changes noted here.</p>"},{"location":"other/pages/networking.html#cyclonedds-multiple-interfaces","title":"CycloneDDS: Multiple Interfaces","text":"<p>Cyclone currently only works with a single network interface. If you have multiple interfaces, specify which one to use in the NetworkInterfaceAddress:</p> <pre><code>&lt;CycloneDDS&gt;\n  &lt;Domain&gt;\n    &lt;General&gt;\n      &lt;NetworkInterfaceAddress&gt;wlp2s0&lt;/NetworkInterfaceAddress&gt;\n    &lt;/General&gt;\n  &lt;/Domain&gt;\n&lt;/CycloneDDS&gt;\n</code></pre>"},{"location":"other/pages/networking.html#cyclonedds-disabling-multicast-except-discovery","title":"CycloneDDS: Disabling Multicast (Except Discovery)","text":"<p>Some network hardware can perform poorly with multicast (especially with WIFI). You can limit multicast to just discovery:</p> <pre><code>&lt;CycloneDDS&gt;\n  &lt;Domain&gt;\n    &lt;General&gt;\n      &lt;AllowMulticast&gt;spdp&lt;/AllowMulticast&gt;\n    &lt;/General&gt;\n  &lt;/Domain&gt;\n&lt;/CycloneDDS&gt;\n</code></pre>"},{"location":"other/pages/networking.html#cyclonedds-domain-tag","title":"CycloneDDS: Domain Tag","text":"<p>CycloneDDS also defines a \"Domain Tag\" which allows to drastically partition the network with a custom string:</p> <pre><code>&lt;CycloneDDS&gt;\n  &lt;Domain&gt;\n    &lt;Discovery&gt;\n      &lt;Tag&gt;my_robot_name&lt;/Tag&gt;\n    &lt;/Discovery&gt;\n  &lt;/Domain&gt;\n&lt;/CycloneDDS&gt;\n</code></pre>"},{"location":"other/pages/networking.html#example","title":"Example","text":"<p>The above tags can all be combined:</p> <pre><code>&lt;CycloneDDS&gt;\n  &lt;Domain&gt;\n    &lt;General&gt;\n      &lt;!-- Explicitly set network interface --&gt;\n      &lt;NetworkInterfaceAddress&gt;wlp2s0&lt;/NetworkInterfaceAddress&gt;\n      &lt;!-- Use multicast for discovery only --&gt;\n      &lt;AllowMulticast&gt;spdp&lt;/AllowMulticast&gt;\n    &lt;/General&gt;\n    &lt;Discovery&gt;\n      &lt;!-- This tag has to be the same on each machine --&gt;\n      &lt;Tag&gt;my_robot_name&lt;/Tag&gt;\n    &lt;/Discovery&gt;\n  &lt;/Domain&gt;\n&lt;/CycloneDDS&gt;\n</code></pre>"},{"location":"other/pages/packages.html","title":"Package Documentation","text":"<p>Currently, documentation is a bit all over the place. This list is certainly not extensive, but I find it helpful to have quick links to the frequently used packages.</p>"},{"location":"other/pages/packages.html#core-documentation","title":"Core Documentation","text":"<ul> <li>ROS 2 Overview</li> <li>Ament CMake</li> <li>ROS 2 Launch</li> </ul>"},{"location":"other/pages/packages.html#higher-level-packages","title":"Higher Level Packages","text":"<ul> <li>MoveIt2</li> <li>If encountering errors about OpenGL Context when running setup assistant, restart the computer. This is usually caused by mismatched versions of NVIDIA drivers.</li> <li>Navigation2</li> </ul>"},{"location":"other/pages/qos.html","title":"QoS (Quality of Service)","text":"<p>A full description of the available QoS settings, and compatability of different settings can be found in the ROS 2 Documentation.</p>"},{"location":"other/pages/qos.html#recommended-practices","title":"Recommended Practices","text":"<ul> <li>REP-2003 defines recommended practices for maps and sensor drivers.</li> <li>The suggested practice for \"sensor drivers\" is also pretty reasonable for most vision pipelines, and    and that is to:</li> <li>Publish with <code>SystemDefaultQoS</code></li> <li>Subscribe with <code>SensorDataQoS</code></li> </ul> <p>Subscribing with <code>SensorDataQoS</code> means that we will get unreliable transport but be more immune to lossy networks. By publishing with <code>SystemDefaultQoS</code> we will still be able to connect to any subscriber as long as they are specifying <code>volatile</code> rather than <code>transient local</code>.</p>"},{"location":"other/pages/qos.html#overrides","title":"Overrides","text":"<p><code>rclcpp</code> offers a consistent way to define QoS overrides as parameters. There is a (somewhat dated/inaccurate) design doc on this feature. In your code:</p> <pre><code>// Allow overriding QoS settings (history, depth, reliability)\nrclcpp::PublisherOptions pub_options;\npub_options.qos_overriding_options = rclcpp::QosOverridingOptions::with_default_policies();\nnode-&gt;create_publisher&lt;std_msgs::msg::String&gt;(\"topic\", rclcpp::QoS(10), pub_options);\n</code></pre> <p>Then, in your parameter file, you can define:</p> <pre><code>node_name:\n  ros__parameters:\n    qos_overrides:\n      fully_resolved_topic_name:\n        publisher:\n          reliability: reliable\n          depth: 100\n          history: keep_last\n</code></pre> <p>[!NOTE] While some documentation uses <code>history_depth</code>, the actual parameter needs to just be <code>depth</code> in order to work. </p> <p>The same workflow works for subscribers, you just use <code>rclcpp::SubscriptionOptions</code> instance and change <code>publisher</code> to <code>subscription</code> in the YAML file.</p>"},{"location":"other/pages/qos.html#magic-numbers","title":"Magic Numbers","text":"<p>[!NOTE] This is fixed in later releases, and QoS profile will show \"Infinite\"</p> <p>If you perform <code>ros2 topic info -v /some/topic</code> and you examine the QoS settings, you may note that several fields are set to the magic number 2147483651294967295 (or 2,147,483,651,294,967,295). e.g. </p> <pre><code>QoS profile:\n    Reliability: RMW_QOS_POLICY_RELIABILITY_RELIABLE\n    Durability: RMW_QOS_POLICY_DURABILITY_VOLATILE\n    Lifespan: 2147483651294967295 nanoseconds\n    Deadline: 2147483651294967295 nanoseconds\n    Liveliness: RMW_QOS_POLICY_LIVELINESS_AUTOMATIC\n    Liveliness lease duration: 2147483651294967295 nanoseconds\n</code></pre> <p>What is the significance of this number, which is approximately equal to 68 years? It's not \\(2^n - 1\\) as you might expect for a magic number. However, durations are defined as </p> <pre><code>[builtin_interfaces/Duration]\n# Seconds component, range is valid over any possible int32 value.\nint32 sec\n\n# Nanoseconds component in the range of [0, 1e9).\nuint32 nanosec\n</code></pre> <p>The max value for an <code>int32</code> is \\(2^{31} - 1\\). The max value for an <code>uint32</code> is \\(2^{32} - 1\\). (Note: According to the definition, any value for <code>nanosec</code> over 1e9 is invalid.)</p> <p>So the magic number 2147483651294967295 is the number of nanoseconds equivalent to \\(2^{31} -1\\) seconds (\\(2147483647\\) seconds) added to \\(2^{32} - 1\\) nanoseconds (\\(4.294967295\\) seconds). </p>"},{"location":"other/pages/rosdep.html","title":"Rosdep","text":"<p><code>rosdep install --from-paths src --ignore-src --rosdistro=humble -y</code></p>"},{"location":"other/pages/rosdoc2.html","title":"rosdoc2","text":"<p>Documentation for ROS 2 packages can be built with rosdoc2.</p> <p>When a <code>doc</code> job is configured in the <code>rosdistro</code>, the resulting documentation is uploaded to <code>docs.ros.org</code>. The design document for per package documentation lays out the directory structure.</p>"},{"location":"other/pages/rosdoc2.html#linking-to-other-packages","title":"Linking to Other Packages","text":"<p>This is a dirty hack, but appears to be the only way to have the table of contents link to another package's documentation without hard-coding the distro. The trailing <code>http://</code> changes how Sphinx processes the link:</p> <pre><code>.. toctree::\n   :maxdepth: 2\n\n   other_package &lt;../other_package/index.html#http://&gt;\n</code></pre> <p>An example of this can be seen in the documentation for image_pipeline, where we want to link to the documentation for each of the packages within the metapackage.</p>"},{"location":"other/pages/rosdoc2.html#documenting-metapackages","title":"Documenting Metapackages","text":"<p>A metapackage is one that contains no code and exists basically to bundle up a set of dependencies. For instance <code>image_pipeline</code> is a repository containing several packages for image processing - and the <code>image_pipeline</code> metapackage depends on every package in the repository to make it easier to install with <code>apt install ros-&lt;distro&gt;-image-pipeline</code> rather than specifying each package individually. This does lead to an issue with <code>rosdoc2</code>, which will fail if there is no code to document. If you want to add tutorials or documentation to a metapackage, you need to use a <code>rosdoc2.yaml</code> file to properly build your documentation (which we assume is located in the <code>doc</code> folder:</p> <pre><code>type: 'rosdoc2 config'\nversion: 1\n\n---\n\nsettings:\n    # Not generating any documentation of code\n    generate_package_index: false\n    always_run_doxygen: false\n    enable_breathe: false\n    enable_exhale: false\n    always_run_sphinx_apidoc: false\n    # Lie to rosdoc2, claim to be a python package\n    override_build_type: 'ament_python'\n    # Lie to rosdoc2 again, say your source is in doc folder\n    python_source: 'doc'\n\nbuilders:\n   # Configure Sphinx with the location of the docs:\n    - sphinx: {\n        name: 'image_pipeline',\n        sphinx_sourcedir: 'doc',\n        output_dir: ''\n    }\n</code></pre> <p>Don't forget to add your yaml file to the <code>package.xml</code>:</p> <pre><code>&lt;export&gt;\n  &lt;rosdoc2&gt;rosdoc2.yaml&lt;/rosdoc2&gt;\n&lt;/export&gt;\n</code></pre>"}]}